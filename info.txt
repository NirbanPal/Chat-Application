#create virtual env
#pip install channels==3.0.5(importatnt install this)
#pip install django(imp install this)
#pip install django-channels(Here it is not used. do not install this here) -->django-channels is a Django library for sending notifications, HipChat, Slack, Twitter

The django-channels package is an extension for Django that enables the development of real-time applications, such as chat applications, notifications systems, and collaborative tools. It provides a way to handle WebSockets, HTTP long-polling, and other asynchronous protocols in Django.

When you install django-channels using pip install django-channels, it adds the necessary functionality to your Django project to work with WebSocket connections and handle asynchronous tasks.

Here are some key features and use cases of django-channels:

WebSocket support: django-channels allows you to handle WebSocket connections in Django. WebSockets provide full-duplex communication channels over a single TCP connection, allowing real-time bidirectional communication between the client and server. With django-channels, you can easily integrate WebSockets into your Django project.

Asynchronous tasks: django-channels provides a way to handle long-running or asynchronous tasks within your Django application. You can offload tasks to worker processes or threads and communicate with them asynchronously using channels.

Real-time updates: With django-channels, you can build real-time features like live updates, notifications, and chat functionality in your Django application. It allows you to send and receive data in real-time between the client and server, enabling interactive and dynamic user experiences.

Protocol handling: django-channels supports various protocols like WebSocket, HTTP long-polling, and others. It abstracts away the complexity of handling different protocols, allowing you to focus on developing your application's functionality.

Integration with Django ecosystem: django-channels seamlessly integrates with the existing Django ecosystem. You can use Django's ORM, authentication, and other features in your real-time applications without needing to learn new frameworks or tools.

Overall, django-channels enhances Django's capabilities by adding real-time and asynchronous functionality, making it a powerful tool for building interactive web applications.



#pip install django channels-->(it is used here)
pip install django channels is a command used to install the Django Channels package, which is an extension for Django, a popular Python web framework. Django Channels allows you to add real-time, bidirectional communication capabilities to your Django applications.

While traditional Django is primarily designed to handle request-response cycles using HTTP, Django Channels enables the development of applications that require persistent connections and real-time updates. It accomplishes this by implementing the WebSocket protocol and providing a way to handle events and messages asynchronously.

Some use cases for Django Channels include building chat applications, real-time dashboards, collaborative editing tools, and notifications systems. By integrating Django Channels into your Django project, you can easily incorporate features that require real-time updates and asynchronous communication.

Once you've installed Django Channels, you can import and use it within your Django application to handle WebSocket connections, manage channels, and handle events and messages in an asynchronous manner.



#If we create template folder in the app then we don't have to assign the directory. like here if we create template/chatapp in the 'chatapp' app then i don't need to assign the path for templates in the settings.py. same for rooms means if we create templates/room folder in the 'rooms' app the we don't need to assign the directory for templates in the settings.py file
#But if we create templates folder in the project file but outside of the app. then we have to assign the path in the settings.py(os.path.join(BASE_DIR,'templates'))

#action="." post request will be send to the same url where you are now


#main part(have not done previously)
#-->Creating consumer->A consumer helps us using web sockets so we can handle connections and disconnections, sending and receiving messages. So it is a typically python script
#we also can use redis and similar if we have to use this in production.but here we are using InMemoryChannelLayer so when it will be shut off it will be lostforever  
# But here for all of the messages that are send will just be stored in the memory of the server so if you shut it off it will not be lost forever


#we have a file urls.py for for our different pages we want similar file for the web socket(here we are creating routing.py for this)

#-->Joining a chat(using a web socket)
#-->sending messages
#if you want to avpid csrf then do pass event through the function and use e.preventDefault() and at the end of the function return false


TO CREATE A CHAT APP FROM SCTRATCH GO THOUGH THIS LINK-> https://channels.readthedocs.io/en/stable/topics/channel_layers.html



REDIS->
Redis is the most popular cache backend the Django developers use. Redis is famous for inmemory datastore. 

Here are some specific examples of how Redis can be used in Django:
Caching:
Redis can be used to cache frequently accessed data, such as database queries, templates, and static files. This can help to improve the performance of your Django application.

Message brokering:
Redis can be used as a message broker for communicating between different components of your Django application. This can help to improve the scalability and reliability of your application.

Database:
Redis can be used as a database for storing small amounts of data. This can be a good option if you need to store data that is not frequently accessed.



as we use request.user so for the web socket we have to use self.scope['user'].

As channel layer is storing the group information and the channels(users(channel info)) which are in the group. We also can use redis/rabbitmq for storing those informations(channel layer can use redis/rabbitmq for storing of the datas and infos). For the testing purpose InMemoryChannelLayer(channel layer uses InMemoryChannelLayer for storing the infos and datas of groups and channels of that group which is good for testing purpose only. Here InMemoryChannelLayer used local ram to store the datas and informations about the group and channels. We can not use the notification system in this also.) is good but in the production you have to use redis or rabbitmq.

As we are creating this chat app in windows and redis is not available for windows that is why we will use redis online service. 

Go to this link to access online redis->https://app.redislabs.com/#/subscriptions/subscription/2175167/bdb-view/11952094/configuration

run-> to install channel_redis
pip install channels_redis.

receive() method in consumer.py file recives the messages and receive() method put that message in to the redis corresponding to the group to which the object(object means messages and inofs) and channel name is asociated.

So here (channel layer will use redis to store)redis will only store the infomations regarding the group name and channel name.


How can we send notification using websocket or how we can create a notifications system?

suppose a ecom website manager has told to send notification to all of the user who are in the database.

So for that we will use self.channel_layer.group_send() method. This function will send the message to all the users that are connected through websockets on our server. 
So we have to create more file in the application folder. So here in the rooms (app) we will create management folder and under that we will create a commands folder and under that folder we have to create notifications.py file(Where we write the code to send the notifications to the users). in this way we have to create management command and send the notifications by running this command py manage.py notifications.py


UVICORN->
Here we are using uvicorn server as asgi server. When you will use uvicorn inMemoryChannellayer(used for only development and tests not in production) will not work(cause it uses ram to store the channels and group name infos and all). So we have to use redis/rabbitmq/memurai. To install Uvicorn server with asgi run this command pip install uvicorn[standard](else for normal asgi server use pip install uvicorn)
To run the server on uvicorn --> uvicorn chatproject.asgi:application

Describe this command-> uvicorn chatproject.asgi:application --workers=4 . So the first part to start uvicorn (asgi server) and the --workers=4 means This flag is used to set the number of worker processes. In your command, it's set to 4.

--workers=4 
By setting --workers=4, you're instructing Uvicorn to start four worker processes to handle incoming requests. This can be beneficial for improving the concurrency and responsiveness of your ASGI application. It allows your application to handle multiple requests at the same time, which is particularly useful for production deployments to handle a potentially large number of concurrent users.

The optimal number of workers may vary depending on the specific characteristics of your application and the resources available on your server. A higher number of workers can improve concurrency but may require more system resources. You should consider factors like the available CPU cores and memory when choosing the number of workers.

It's common to experiment with different values to find the optimal number of workers for your application. The appropriate number of workers can depend on the workload and server capacity, so performance testing and monitoring can help determine the best configuration for your particular use case.



NOTE-> about django.setup()

It is used if you run your Django app as standalone(standalone means indipendently). It will load your settings and populate Django's application registry.django.setup() may only be called once
